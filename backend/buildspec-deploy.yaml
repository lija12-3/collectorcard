version: 0.2

env:
  variables:
    AWS_DEFAULT_REGION: "us-east-1"
    EKS_CLUSTER_NAME: "dev-eks-fargate-cluster"
    NAMESPACE: "collectors-card-app-dev"
    IMAGE_REPO: "782496497250.dkr.ecr.us-east-1.amazonaws.com/collectors-card/app"
    EKS_DEPLOY_ROLE_ARN: ""

phases:
  install:
    runtime-versions:
      python: 3.9
    commands:
      - set -euo pipefail
      - echo "üîß Installing kubectl if missing..."
      - |
        if ! command -v kubectl &> /dev/null; then
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl
          mv kubectl /usr/local/bin/
        fi
      - kubectl version --client || true
      - echo "üìÅ Changing to backend directory..."
      - cd backend

  pre_build:
    commands:
      - echo "üîê Configuring kubeconfig for EKS cluster $EKS_CLUSTER_NAME..."
      - |
        if [ -n "$EKS_DEPLOY_ROLE_ARN" ] && [ "$EKS_DEPLOY_ROLE_ARN" != " " ]; then
          echo "Using role ARN: $EKS_DEPLOY_ROLE_ARN to update kubeconfig"
          aws eks update-kubeconfig --name "$EKS_CLUSTER_NAME" --region "$AWS_DEFAULT_REGION" --role-arn "$EKS_DEPLOY_ROLE_ARN"
        else
          aws eks update-kubeconfig --name "$EKS_CLUSTER_NAME" --region "$AWS_DEFAULT_REGION"
        fi
      - echo "‚úÖ Verifying cluster access..."
      - kubectl get nodes || (kubectl get ns && echo "cluster access ok")
      - echo "üì¶ Reading image URI from build artifact (prefer image-uri.txt)..."
      - cd $CODEBUILD_SRC_DIR
      - |
        if [ -f build_output/image-uri.txt ]; then
          IMAGE_URI=$(cat build_output/image-uri.txt)
        elif [ -f build_output/image-tag.txt ]; then
          IMAGE_TAG=$(cat build_output/image-tag.txt)
          IMAGE_URI="$IMAGE_REPO:$IMAGE_TAG"
        else
          echo "ERROR: image-uri.txt or image-tag.txt not found in artifact"
          exit 1
        fi
      - echo "‚úÖ Will deploy image: $IMAGE_URI"
      - echo "üß± Ensuring namespace '$NAMESPACE' exists..."
      - kubectl get namespace "$NAMESPACE" >/dev/null 2>&1 || kubectl create namespace "$NAMESPACE"
      - cd backend

  build:
    commands:
      - echo "üöÄ Deploying to namespace: $NAMESPACE"
      - |
        if kubectl get deployment collectors-card-app -n "$NAMESPACE" >/dev/null 2>&1; then
          echo "Deployment exists ‚Äî updating image..."
          kubectl set image deployment/collectors-card-app collectors-card-app="$IMAGE_URI" -n "$NAMESPACE" --record
        else
          echo "Deployment does not exist ‚Äî creating resources from manifests..."
          kubectl apply -f k8s/deployment.yaml -n "$NAMESPACE"
          kubectl apply -f k8s/service.yaml -n "$NAMESPACE"
          kubectl set image deployment/collectors-card-app collectors-card-app="$IMAGE_URI" -n "$NAMESPACE" --record
        fi
      - echo "‚è≥ Waiting for rollout to complete..."
      - kubectl rollout status deployment/collectors-card-app -n "$NAMESPACE" --timeout=10m

  post_build:
    commands:
      - echo "‚úÖ Deployment completed successfully!"
      - echo "üîç Deployment details:"
      - kubectl get deployment collectors-card-app -n "$NAMESPACE" -o wide || true
      - echo ""
      - echo "üìä Pod status:"
      - kubectl get pods -n "$NAMESPACE" -l app=collectors-card-app || true